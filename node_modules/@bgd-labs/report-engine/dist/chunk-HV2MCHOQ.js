// src/renderer/reserve.ts
var getBlockExplorerLink = {
  [1 /* MAINNET */]: (address) => `[${address}](https://etherscan.io/address/${address})`
};
function renderValue(key, reserve, chainId) {
  if ([
    "reserveFactor",
    "liquidationProtocolFee",
    "liquidationThreshold",
    "ltv"
  ].includes(key))
    return `${reserve[key] / 100} %`;
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (key === "liquidationBonus")
    return `${(reserve[key] - 1e4) / 100} %`;
  if (typeof reserve[key] === "number")
    return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return getBlockExplorerLink[chainId](reserve[key]);
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${getBlockExplorerLink[chainId](
    reserve.underlying
  )})

`;
}
var ORDER = ["supplyCap", "borrowCap"];
function sortReserveKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
function renderReserveConfig(reserve, chainId) {
  let content = "";
  const OMIT_KEYS = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserveConfigDiff(reserve, chainId) {
  let content = "";
  Object.keys(reserve).filter((key) => reserve[key].from).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderValue(
      key,
      { ...reserve, [key]: reserve[key].from },
      chainId
    )} | ${renderValue(
      key,
      { ...reserve, [key]: reserve[key].to },
      chainId
    )} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += renderReserveConfigDiff(diff2, chainId);
  return content;
}

// src/utils/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] == a[key]) {
          if (!removeUnchanged)
            out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key))
      continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/diffReports.ts
function diffReports(pre, post) {
  const diffResult = diff(pre, post);
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      return renderReserve(diffResult.reserves[reserveKey].to, 1);
    }
  });
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(diffResult.reserves[reserveKey].from, 1);
    }
  });
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (Object.keys(diffResult.reserves[reserveKey]).find(
      (fieldKey) => typeof diffResult.reserves[reserveKey][fieldKey] === "object"
    )) {
      return renderReserveDiff(diffResult.reserves[reserveKey], 1);
    }
  });
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `## ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      reservesAdded.forEach((report) => {
        content += report;
      });
    }
    if (reservesAltered.length) {
      content += `## ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      reservesAltered.forEach((report) => {
        content += report;
      });
    }
    if (reservesRemoved.length) {
      content += `## ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      reservesRemoved.forEach((report) => {
        content += report;
      });
    }
  }
  content += `### Raw diff

\`\`\`json
${JSON.stringify(
    diff(pre, post, true),
    null,
    2
  )}
\`\`\``;
  return content;
}

export {
  diffReports
};
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=chunk-HV2MCHOQ.js.map