// src/fetchIRStrategy.ts
import fs from "fs";
import path from "path";
import { Readable } from "stream";
import { finished } from "stream/promises";
async function fetchRateStrategyImage(rate, fileName) {
  const relativePath = path.join(process.cwd(), ".assets");
  const pathWithFile = path.join(relativePath, `${fileName}.svg`);
  if (fs.existsSync(pathWithFile))
    return;
  if (!fs.existsSync(relativePath)) {
    fs.mkdirSync(relativePath, { recursive: true });
  }
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    stableRateSlope1: rate.stableRateSlope1,
    stableRateSlope2: rate.stableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    baseStableBorrowRate: rate.baseStableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  const { body } = await fetch(
    `https://rate-strategy-explorer.vercel.app/api/static?${searchParams.toString()}`
  );
  const fileStream = fs.createWriteStream(pathWithFile);
  if (!body)
    throw Error("Error fetchign the image");
  await finished(Readable.fromWeb(body).pipe(fileStream));
}

// src/types.ts
import { z } from "zod";
var aaveV3ConfigSchema = z.object({
  oracle: z.string(),
  pool: z.string(),
  poolAddressesProvider: z.string(),
  poolConfigurator: z.string(),
  poolConfiguratorImpl: z.string(),
  poolImpl: z.string(),
  protocolDataProvider: z.string()
});
var aaveV3ReserveSchema = z.object({
  isBorrowableInIsolation: z.boolean(),
  borrowCap: z.number(),
  liquidationBonus: z.number(),
  underlying: z.string(),
  isFrozen: z.boolean(),
  stableDebtToken: z.string(),
  variableDebtToken: z.string(),
  reserveFactor: z.number(),
  liquidationProtocolFee: z.number(),
  usageAsCollateralEnabled: z.boolean(),
  ltv: z.number(),
  supplyCap: z.number(),
  debtCeiling: z.number(),
  borrowingEnabled: z.boolean(),
  isActive: z.boolean(),
  eModeCategory: z.number(),
  symbol: z.string(),
  stableBorrowRateEnabled: z.boolean(),
  isFlashloanable: z.boolean(),
  aToken: z.string(),
  liquidationThreshold: z.number(),
  aTokenImpl: z.string(),
  stableDebtTokenImpl: z.string(),
  interestRateStrategy: z.string(),
  variableDebtTokenImpl: z.string(),
  oracleLatestAnswer: z.number(),
  oracle: z.string(),
  decimals: z.number(),
  isSiloed: z.boolean()
});
var aaveV3StrategySchema = z.object({
  baseStableBorrowRate: z.number(),
  maxExcessStableToTotalDebtRatio: z.number(),
  address: z.string(),
  baseVariableBorrowRate: z.number(),
  stableRateSlope2: z.number(),
  optimalUsageRatio: z.number(),
  variableRateSlope2: z.number(),
  optimalStableToTotalDebtRatio: z.number(),
  maxExcessUsageRatio: z.number(),
  stableRateSlope1: z.number(),
  variableRateSlope1: z.number()
});
var aaveV3EmodeSchema = z.object({
  eModeCategory: z.number(),
  liquidationBonus: z.number(),
  label: z.string(),
  liquidationThreshold: z.number(),
  priceSource: z.string(),
  ltv: z.number()
});
var CHAIN_ID = {
  MAINNET: 1,
  OPTIMISM: 10,
  POLYGON: 137,
  FANTOM: 250,
  ARBITRUM: 42161,
  AVALANCHE: 43114
};
var zodChainId = z.nativeEnum(CHAIN_ID);
var aaveV3SnapshotSchema = z.object({
  reserves: z.record(aaveV3ReserveSchema),
  strategies: z.record(aaveV3StrategySchema),
  eModes: z.record(aaveV3EmodeSchema),
  poolConfig: aaveV3ConfigSchema,
  chainId: zodChainId
});

// src/renderer/reserve.ts
var getBlockExplorerLink = {
  [CHAIN_ID.MAINNET]: (address) => `[${address}](https://etherscan.io/address/${address})`,
  [CHAIN_ID.OPTIMISM]: (address) => `[${address}](https://optimistic.etherscan.io/address/${address})`,
  [CHAIN_ID.POLYGON]: (address) => `[${address}](https://polygonscan.com/address/${address})`,
  [CHAIN_ID.FANTOM]: (address) => `[${address}](https://ftmscan.com/address/${address})`,
  [CHAIN_ID.ARBITRUM]: (address) => `[${address}](https://https://arbiscan.io/address/${address})`,
  [CHAIN_ID.AVALANCHE]: (address) => `[${address}](https://snowtrace.io/address/${address})`
};
function renderValue(key, reserve, chainId) {
  if ([
    "reserveFactor",
    "liquidationProtocolFee",
    "liquidationThreshold",
    "ltv"
  ].includes(key))
    return `${reserve[key] / 100} %`;
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (key === "liquidationBonus")
    return `${(reserve[key] - 1e4) / 100} %`;
  if (key === "interestRateStrategy")
    return `![${getBlockExplorerLink[chainId](
      reserve[key]
    )}](/assets/${chainId}_${reserve[key]}.svg)`;
  if (typeof reserve[key] === "number")
    return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return getBlockExplorerLink[chainId](reserve[key]);
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${getBlockExplorerLink[chainId](
    reserve.underlying
  )})

`;
}
var ORDER = ["supplyCap", "borrowCap"];
function sortReserveKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
function renderReserveConfig(reserve, chainId) {
  let content = "| description | value |\n| --- | --- |\n";
  const OMIT_KEYS = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserveConfigDiff(reserve, chainId) {
  let content = "| description | value before | value after |\n| --- | --- | --- |\n";
  Object.keys(reserve).filter((key) => reserve[key].from).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderValue(
      key,
      { ...reserve, [key]: reserve[key].from },
      chainId
    )} | ${renderValue(
      key,
      { ...reserve, [key]: reserve[key].to },
      chainId
    )} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += renderReserveConfigDiff(diff2, chainId);
  return content;
}

// src/utils/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] == a[key]) {
          if (!removeUnchanged)
            out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key))
      continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/diffReports.ts
async function diffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  for (const ir in pre.strategies) {
    await fetchRateStrategyImage(pre.strategies[ir], `${chainId}_${ir}`);
  }
  for (const ir in post.strategies) {
    await fetchRateStrategyImage(pre.strategies[ir], `${chainId}_${ir}`);
  }
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      return renderReserve(
        diffResult.reserves[reserveKey].to,
        chainId
      );
    }
  }).filter((i) => i);
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(
        diffResult.reserves[reserveKey].from,
        chainId
      );
    }
  }).filter((i) => i);
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (!diffResult.reserves[reserveKey].hasOwnProperty("from") && Object.keys(diffResult.reserves[reserveKey]).find(
      (fieldKey) => typeof diffResult.reserves[reserveKey][fieldKey] === "object"
    )) {
      console.log(diffResult.reserves[reserveKey]);
      return renderReserveDiff(
        diffResult.reserves[reserveKey],
        chainId
      );
    }
  }).filter((i) => i);
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `### ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      content += reservesAdded.join("\n\n");
      content += "\n\n";
    }
    if (reservesAltered.length) {
      content += `### ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      content += reservesAltered.join("\n\n");
      content += "\n\n";
    }
    if (reservesRemoved.length) {
      content += `### ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      content += reservesRemoved.join("\n\n");
      content += "\n\n";
    }
  }
  content += `## Raw diff

\`\`\`json
${JSON.stringify(
    diff(pre, post, true),
    null,
    2
  )}
\`\`\``;
  return content;
}

export {
  diffReports
};
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=chunk-FZC43XF2.js.map