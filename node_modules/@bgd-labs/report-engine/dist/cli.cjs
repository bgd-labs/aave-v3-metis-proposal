#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_yargs = __toESM(require("yargs/yargs"), 1);
var import_helpers = require("yargs/helpers");

// src/diffReports.ts
var import_object_hash2 = __toESM(require("object-hash"), 1);

// src/fetchIRStrategy.ts
var import_path = __toESM(require("path"), 1);
var import_fs = require("fs");
var import_stream = require("stream");
var import_util = require("util");
var import_node_fetch = __toESM(require("node-fetch"), 1);
var import_object_hash = __toESM(require("object-hash"), 1);
var streamPipeline = (0, import_util.promisify)(import_stream.pipeline);
async function fetchRateStrategyImage(rate) {
  const fileHash = (0, import_object_hash.default)(rate);
  const relativePath = import_path.default.join(process.cwd(), ".assets");
  const pathWithFile = import_path.default.join(relativePath, `${fileHash}.svg`);
  if ((0, import_fs.existsSync)(pathWithFile))
    return;
  if (!(0, import_fs.existsSync)(relativePath)) {
    (0, import_fs.mkdirSync)(relativePath, { recursive: true });
  }
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    stableRateSlope1: rate.stableRateSlope1,
    stableRateSlope2: rate.stableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    baseStableBorrowRate: rate.baseStableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  const { body } = await (0, import_node_fetch.default)(
    `https://rate-strategy-explorer.vercel.app/api/static?${searchParams.toString()}`
  );
  if (!body)
    throw Error("Error fetchign the image");
  await streamPipeline(body, (0, import_fs.createWriteStream)(pathWithFile));
}

// src/renderer/reserve.ts
var import_viem = require("viem");

// src/types.ts
var import_zod = require("zod");
var aaveV3ConfigSchema = import_zod.z.object({
  oracle: import_zod.z.string(),
  pool: import_zod.z.string(),
  poolAddressesProvider: import_zod.z.string(),
  poolConfigurator: import_zod.z.string(),
  poolConfiguratorImpl: import_zod.z.string(),
  poolImpl: import_zod.z.string(),
  protocolDataProvider: import_zod.z.string()
});
var aaveV3ReserveSchema = import_zod.z.object({
  isBorrowableInIsolation: import_zod.z.boolean(),
  borrowCap: import_zod.z.number(),
  liquidationBonus: import_zod.z.number(),
  underlying: import_zod.z.string(),
  isFrozen: import_zod.z.boolean(),
  stableDebtToken: import_zod.z.string(),
  variableDebtToken: import_zod.z.string(),
  reserveFactor: import_zod.z.number(),
  liquidationProtocolFee: import_zod.z.number(),
  usageAsCollateralEnabled: import_zod.z.boolean(),
  ltv: import_zod.z.number(),
  supplyCap: import_zod.z.number(),
  debtCeiling: import_zod.z.number(),
  borrowingEnabled: import_zod.z.boolean(),
  isActive: import_zod.z.boolean(),
  eModeCategory: import_zod.z.number(),
  symbol: import_zod.z.string(),
  stableBorrowRateEnabled: import_zod.z.boolean(),
  isFlashloanable: import_zod.z.boolean(),
  aToken: import_zod.z.string(),
  liquidationThreshold: import_zod.z.number(),
  aTokenImpl: import_zod.z.string(),
  stableDebtTokenImpl: import_zod.z.string(),
  interestRateStrategy: import_zod.z.string(),
  variableDebtTokenImpl: import_zod.z.string(),
  oracleLatestAnswer: import_zod.z.number(),
  oracle: import_zod.z.string(),
  oracleDecimals: import_zod.z.number(),
  oracleName: import_zod.z.string(),
  oracleDescription: import_zod.z.string(),
  decimals: import_zod.z.number(),
  isSiloed: import_zod.z.boolean()
});
var aaveV3StrategySchema = import_zod.z.object({
  baseStableBorrowRate: import_zod.z.string(),
  maxExcessStableToTotalDebtRatio: import_zod.z.string(),
  address: import_zod.z.string(),
  baseVariableBorrowRate: import_zod.z.string(),
  stableRateSlope2: import_zod.z.string(),
  optimalUsageRatio: import_zod.z.string(),
  variableRateSlope2: import_zod.z.string(),
  optimalStableToTotalDebtRatio: import_zod.z.string(),
  maxExcessUsageRatio: import_zod.z.string(),
  stableRateSlope1: import_zod.z.string(),
  variableRateSlope1: import_zod.z.string()
});
var aaveV3EmodeSchema = import_zod.z.object({
  eModeCategory: import_zod.z.number(),
  liquidationBonus: import_zod.z.number(),
  label: import_zod.z.string(),
  liquidationThreshold: import_zod.z.number(),
  priceSource: import_zod.z.string(),
  ltv: import_zod.z.number()
});
var CHAIN_ID = {
  MAINNET: 1,
  OPTIMISM: 10,
  POLYGON: 137,
  FANTOM: 250,
  ARBITRUM: 42161,
  AVALANCHE: 43114
};
var zodChainId = import_zod.z.nativeEnum(CHAIN_ID);
var aaveV3SnapshotSchema = import_zod.z.object({
  reserves: import_zod.z.record(aaveV3ReserveSchema),
  strategies: import_zod.z.record(aaveV3StrategySchema),
  eModes: import_zod.z.record(aaveV3EmodeSchema),
  poolConfig: aaveV3ConfigSchema,
  chainId: zodChainId
});

// src/renderer/reserve.ts
var getBlockExplorerLink = {
  [CHAIN_ID.MAINNET]: (address) => `[${address}](https://etherscan.io/address/${address})`,
  [CHAIN_ID.OPTIMISM]: (address) => `[${address}](https://optimistic.etherscan.io/address/${address})`,
  [CHAIN_ID.POLYGON]: (address) => `[${address}](https://polygonscan.com/address/${address})`,
  [CHAIN_ID.FANTOM]: (address) => `[${address}](https://ftmscan.com/address/${address})`,
  [CHAIN_ID.ARBITRUM]: (address) => `[${address}](https://https://arbiscan.io/address/${address})`,
  [CHAIN_ID.AVALANCHE]: (address) => `[${address}](https://snowtrace.io/address/${address})`
};
function renderReserveValue(key, reserve, chainId) {
  if ([
    "reserveFactor",
    "liquidationProtocolFee",
    "liquidationThreshold",
    "ltv"
  ].includes(key))
    return `${reserve[key] / 100} %`;
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (key === "liquidationBonus")
    return `${(reserve[key] - 1e4) / 100} %`;
  if (key === "interestRateStrategy")
    return getBlockExplorerLink[chainId](reserve[key]);
  if (key === "oracleLatestAnswer" && reserve.oracleDecimals)
    return (0, import_viem.formatUnits)(BigInt(reserve[key]), reserve.oracleDecimals);
  if (typeof reserve[key] === "number")
    return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return getBlockExplorerLink[chainId](reserve[key]);
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${getBlockExplorerLink[chainId](
    reserve.underlying
  )})

`;
}
var ORDER = [
  "supplyCap",
  "borrowCap",
  "oracle",
  "oracleDecimals",
  "oracleDescription",
  "oracleName",
  "oracleLatestAnswer"
];
function sortReserveKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
function renderReserveConfig(reserve, chainId) {
  let content = "| description | value |\n| --- | --- |\n";
  const OMIT_KEYS2 = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS2.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += "| description | value before | value after |\n| --- | --- | --- |\n";
  Object.keys(diff2).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(
      key,
      { ...diff2, [key]: diff2[key].from },
      chainId
    )} | ${renderReserveValue(
      key,
      { ...diff2, [key]: diff2[key].to },
      chainId
    )} |
`;
  });
  return content;
}

// src/renderer/strategy.ts
var import_viem2 = require("viem");
function renderStrategyValue(key, reserve) {
  return `${(0, import_viem2.formatUnits)(BigInt(reserve[key]), 25)} %`;
}
var ORDER2 = [
  "optimalUsageRatio",
  "maxExcessUsageRatio",
  "baseVariableBorrowRate",
  "variableRateSlope1",
  "variableRateSlope2",
  "baseStableBorrowRate",
  "stableRateSlope1",
  "stableRateSlope2",
  "optimalStableToTotalDebtRatio",
  "maxExcessStableToTotalDebtRatio"
];
function sortStrategyKeys(a, b) {
  const indexA = ORDER2.indexOf(a);
  const indexB = ORDER2.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS = [
  "address"
  // already rendered in the reserve
];
function renderStrategy(strategy) {
  let content = "";
  Object.keys(strategy).filter((key) => !OMIT_KEYS.includes(key)).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, strategy)} |
`;
  });
  return content;
}
function renderStrategyDiff(diff2) {
  let content = "";
  Object.keys(diff2).filter((key) => !OMIT_KEYS.includes(key)).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, {
      ...diff2,
      [key]: diff2[key].from
    })} | ${renderStrategyValue(key, { ...diff2, [key]: diff2[key].to })} |
`;
  });
  return content;
}

// src/utils/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] == a[key]) {
          if (!removeUnchanged)
            out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key))
      continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/diffReports.ts
async function diffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  for (const ir in pre.strategies) {
    await fetchRateStrategyImage(pre.strategies[ir]);
  }
  for (const ir in post.strategies) {
    await fetchRateStrategyImage(post.strategies[ir]);
  }
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      let report = renderReserve(
        diffResult.reserves[reserveKey].to,
        chainId
      );
      const imageHash = (0, import_object_hash2.default)(
        post.strategies[diffResult.reserves[reserveKey].to.interestRateStrategy]
      );
      report += renderStrategy(
        post.strategies[diffResult.reserves[reserveKey].to.interestRateStrategy]
      );
      report += `| interestRate | ![ir](/.assets/${imageHash}.svg) |`;
      return report;
    }
  }).filter((i) => i);
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(
        diffResult.reserves[reserveKey].from,
        chainId
      );
    }
  }).filter((i) => i);
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (!diffResult.reserves[reserveKey].hasOwnProperty("from") && Object.keys(diffResult.reserves[reserveKey]).find(
      (fieldKey) => typeof diffResult.reserves[reserveKey][fieldKey] === "object"
    )) {
      let report = renderReserveDiff(
        diffResult.reserves[reserveKey],
        chainId
      );
      if (diffResult.reserves[reserveKey].interestRateStrategy.hasOwnProperty(
        "from"
      )) {
        report += renderStrategyDiff(
          diff(
            pre.strategies[diffResult.reserves[reserveKey].interestRateStrategy.from],
            post.strategies[diffResult.reserves[reserveKey].interestRateStrategy.to]
          )
        );
        report += `| interestRate | ![before](/.assets/${(0, import_object_hash2.default)(
          pre.strategies[diffResult.reserves[reserveKey].interestRateStrategy.from]
        )}.svg) | ![after](/.assets/${(0, import_object_hash2.default)(
          post.strategies[diffResult.reserves[reserveKey].interestRateStrategy.to]
        )}.svg) |`;
      }
      return report;
    }
  }).filter((i) => i);
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `### ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      content += reservesAdded.join("\n\n");
      content += "\n\n";
    }
    if (reservesAltered.length) {
      content += `### ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      content += reservesAltered.join("\n\n");
      content += "\n\n";
    }
    if (reservesRemoved.length) {
      content += `### ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      content += reservesRemoved.join("\n\n");
      content += "\n\n";
    }
  }
  content += `## Raw diff

\`\`\`json
${JSON.stringify(
    diff(pre, post, true),
    null,
    2
  )}
\`\`\``;
  return content;
}

// src/utils/json.ts
var import_json_bigint = __toESM(require("json-bigint"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);
function readJson(filePath) {
  const content = import_fs2.default.readFileSync(import_path2.default.join(process.cwd(), filePath));
  return JSON.parse(
    JSON.stringify((0, import_json_bigint.default)({ storeAsString: true }).parse(content))
  );
}

// src/cli.ts
var import_fs3 = __toESM(require("fs"), 1);
(0, import_yargs.default)((0, import_helpers.hideBin)(process.argv)).scriptName("aave-report-engine").usage("$0 <cmd> [args]").command(
  "diff [from] [to] [out]",
  "diffs two json reports",
  (yargs2) => {
    yargs2.positional("from", {
      type: "string",
      describe: "the initial json"
    });
    yargs2.positional("to", {
      type: "string",
      describe: "the final json"
    });
    yargs2.positional("out", {
      type: "string",
      describe: "the output path & filename"
    });
  },
  async function(argv) {
    const from = readJson(argv.from);
    const to = readJson(argv.to);
    const content = await diffReports(from, to);
    import_fs3.default.writeFileSync(argv.out, content);
  }
).help().argv;
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=cli.cjs.map