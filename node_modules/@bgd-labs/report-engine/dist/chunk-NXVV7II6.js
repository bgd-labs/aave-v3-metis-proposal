// src/fetchIRStrategy.ts
import fs from "fs";
import { Readable } from "stream";
import { finished } from "stream/promises";
async function fetchRateStrategyImage(rate, path) {
  if (fs.existsSync(path))
    return;
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    stableRateSlope1: rate.stableRateSlope1,
    stableRateSlope2: rate.stableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    baseStableBorrowRate: rate.baseStableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  const { body } = await fetch(
    `https://rate-strategy-explorer.vercel.app/api/static?${searchParams.toString()}`
  );
  const fileStream = fs.createWriteStream(path);
  if (!body)
    throw Error("Error fetchign the image");
  await finished(Readable.fromWeb(body).pipe(fileStream));
}

// src/renderer/reserves.ts
function renderReserves(from, to, reserves) {
  const { added, removed, altered } = Object.entries(reserves).sort(([keyA], [keyB]) => {
    return keyA.localeCompare(keyB, "en-US");
  }).reduce(
    (acc, [key, value]) => {
      if (value.from) {
        acc.removed.push(value.from);
      } else if (value.to) {
        acc.added.push(value.to);
      } else {
        acc.altered.push(value);
      }
      return acc;
    },
    {
      added: [],
      removed: [],
      altered: []
    }
  );
  if (!altered.length && !added.length && !removed.length)
    return "";
  let content = "";
  content += `## Reserves

`;
  if (altered.length) {
    content += `### Reserves altered

`;
    for (const reserve of altered) {
      if (reserve.interestRateStrategy) {
        fetchRateStrategyImage(
          from.strategies[reserve.interestRateStrategy.from],
          `./assets/${reserve.interestRateStrategy.from}`
        );
        fetchRateStrategyImage(
          to.strategies[reserve.interestRateStrategy.to],
          `./assets/${reserve.interestRateStrategy.to}`
        );
      }
      content += `| key | value |
`;
      content += `| --- | --- |
`;
      Object.keys(reserve).map((key) => {
        content += `| ${key} | ~~${reserve[key].from}~~${reserve[key].to} |
`;
      });
      content += `

`;
    }
  }
  if (added.length) {
    content += `### Reserves added

`;
    for (const reserve of added) {
      if (reserve.interestRateStrategy) {
        fetchRateStrategyImage(
          to.strategies[reserve.interestRateStrategy],
          `./assets/${reserve.interestRateStrategy}`
        );
      }
      content += `| key | value |
`;
      content += `| --- | --- |
`;
      Object.keys(reserve).map((key) => {
        content += `| ${key} | ${reserve[key]} |
`;
      });
      content += `

`;
    }
  }
  if (removed.length) {
    content += `### Reserves added

`;
    for (const reserve of removed) {
      content += `| key | value |
`;
      content += `| --- | --- |
`;
      Object.keys(reserve).map((key) => {
        content += `| ${key} | ${reserve[key]} |
`;
      });
      content += `

`;
    }
  }
  return content;
}

// src/utils/diffler.ts
function diffler(obj1, obj2) {
  let diff = {};
  for (const key in obj1) {
    if (obj1.hasOwnProperty(key) && typeof obj1[key] !== "function") {
      const obj1Val = obj1[key];
      const obj2Val = obj2[key];
      if (typeof obj1Val !== typeof obj2Val) {
        diff[key] = {
          from: obj1Val,
          to: obj2Val
        };
        break;
      }
      if (!(key in obj2)) {
        diff[key] = {
          from: obj1Val,
          to: null
          // using null to specify that the value is empty in obj2
        };
      } else if (typeof obj1Val === "object") {
        var tempDiff = diffler(
          obj1Val,
          obj2Val
        );
        if (Object.keys(tempDiff).length > 0) {
          if (tempDiff) {
            diff[key] = tempDiff;
          }
        }
      } else if (obj1Val !== obj2Val) {
        diff[key] = {
          from: obj1Val,
          to: obj2Val
        };
      }
    }
  }
  for (const key in obj2) {
    if (obj2.hasOwnProperty(key) && typeof obj2[key] !== "function") {
      if (obj1 === null) {
        diff[key] = {
          from: obj1,
          to: obj2[key]
        };
        break;
      }
      const obj2Val = obj2[key];
      if (!(key in obj1)) {
        if (!diff) {
          diff = {};
        }
        diff[key] = {
          from: null,
          to: obj2Val
        };
      }
    }
  }
  return diff;
}

// src/diffReports.ts
function diffReports(pre, post) {
  const diff = diffler(pre, post);
  let content = renderReserves(pre, post, diff.reserves);
  content += `### Raw diff

\`\`\`json
${JSON.stringify(
    diff,
    null,
    2
  )}
\`\`\``;
  return content;
}

export {
  diffReports
};
/**
 * @dev this is a modified version of the `diffler` npm package.
 * The modification adds exact types.
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=chunk-NXVV7II6.js.map