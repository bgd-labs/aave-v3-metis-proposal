// src/diffReports.ts
import hash2 from "object-hash";

// src/fetchIRStrategy.ts
import path from "path";
import { existsSync, mkdirSync, createWriteStream } from "fs";
import { pipeline } from "stream";
import { promisify } from "util";
import fetch from "node-fetch";
import hash from "object-hash";
var streamPipeline = promisify(pipeline);
async function fetchRateStrategyImage(rate) {
  const fileHash = hash(rate);
  const relativePath = path.join(process.cwd(), ".assets");
  const pathWithFile = path.join(relativePath, `${fileHash}.svg`);
  if (existsSync(pathWithFile))
    return;
  if (!existsSync(relativePath)) {
    mkdirSync(relativePath, { recursive: true });
  }
  const paramsObj = {
    variableRateSlope1: rate.variableRateSlope1,
    variableRateSlope2: rate.variableRateSlope2,
    stableRateSlope1: rate.stableRateSlope1,
    stableRateSlope2: rate.stableRateSlope2,
    optimalUsageRatio: rate.optimalUsageRatio,
    baseVariableBorrowRate: rate.baseVariableBorrowRate,
    baseStableBorrowRate: rate.baseStableBorrowRate
  };
  const searchParams = new URLSearchParams(paramsObj);
  const { body } = await fetch(
    `https://rate-strategy-explorer.vercel.app/api/static?${searchParams.toString()}`
  );
  if (!body)
    throw Error("Error fetchign the image");
  await streamPipeline(body, createWriteStream(pathWithFile));
}

// src/renderer/reserve.ts
import { formatUnits } from "viem";

// src/types.ts
import { z } from "zod";
var aaveV3ConfigSchema = z.object({
  oracle: z.string(),
  pool: z.string(),
  poolAddressesProvider: z.string(),
  poolConfigurator: z.string(),
  poolConfiguratorImpl: z.string(),
  poolImpl: z.string(),
  protocolDataProvider: z.string()
});
var aaveV3ReserveSchema = z.object({
  isBorrowableInIsolation: z.boolean(),
  borrowCap: z.number(),
  liquidationBonus: z.number(),
  underlying: z.string(),
  isFrozen: z.boolean(),
  stableDebtToken: z.string(),
  variableDebtToken: z.string(),
  reserveFactor: z.number(),
  liquidationProtocolFee: z.number(),
  usageAsCollateralEnabled: z.boolean(),
  ltv: z.number(),
  supplyCap: z.number(),
  debtCeiling: z.number(),
  borrowingEnabled: z.boolean(),
  isActive: z.boolean(),
  eModeCategory: z.number(),
  symbol: z.string(),
  stableBorrowRateEnabled: z.boolean(),
  isFlashloanable: z.boolean(),
  aToken: z.string(),
  liquidationThreshold: z.number(),
  aTokenImpl: z.string(),
  stableDebtTokenImpl: z.string(),
  interestRateStrategy: z.string(),
  variableDebtTokenImpl: z.string(),
  oracleLatestAnswer: z.number(),
  oracle: z.string(),
  oracleDecimals: z.number(),
  oracleName: z.string(),
  oracleDescription: z.string(),
  decimals: z.number(),
  isSiloed: z.boolean()
});
var aaveV3StrategySchema = z.object({
  baseStableBorrowRate: z.string(),
  maxExcessStableToTotalDebtRatio: z.string(),
  address: z.string(),
  baseVariableBorrowRate: z.string(),
  stableRateSlope2: z.string(),
  optimalUsageRatio: z.string(),
  variableRateSlope2: z.string(),
  optimalStableToTotalDebtRatio: z.string(),
  maxExcessUsageRatio: z.string(),
  stableRateSlope1: z.string(),
  variableRateSlope1: z.string()
});
var aaveV3EmodeSchema = z.object({
  eModeCategory: z.number(),
  liquidationBonus: z.number(),
  label: z.string(),
  liquidationThreshold: z.number(),
  priceSource: z.string(),
  ltv: z.number()
});
var CHAIN_ID = {
  MAINNET: 1,
  OPTIMISM: 10,
  POLYGON: 137,
  FANTOM: 250,
  ARBITRUM: 42161,
  AVALANCHE: 43114
};
var zodChainId = z.nativeEnum(CHAIN_ID);
var aaveV3SnapshotSchema = z.object({
  reserves: z.record(aaveV3ReserveSchema),
  strategies: z.record(aaveV3StrategySchema),
  eModes: z.record(aaveV3EmodeSchema),
  poolConfig: aaveV3ConfigSchema,
  chainId: zodChainId
});

// src/renderer/reserve.ts
var getBlockExplorerLink = {
  [CHAIN_ID.MAINNET]: (address) => `[${address}](https://etherscan.io/address/${address})`,
  [CHAIN_ID.OPTIMISM]: (address) => `[${address}](https://optimistic.etherscan.io/address/${address})`,
  [CHAIN_ID.POLYGON]: (address) => `[${address}](https://polygonscan.com/address/${address})`,
  [CHAIN_ID.FANTOM]: (address) => `[${address}](https://ftmscan.com/address/${address})`,
  [CHAIN_ID.ARBITRUM]: (address) => `[${address}](https://https://arbiscan.io/address/${address})`,
  [CHAIN_ID.AVALANCHE]: (address) => `[${address}](https://snowtrace.io/address/${address})`
};
function renderReserveValue(key, reserve, chainId) {
  if ([
    "reserveFactor",
    "liquidationProtocolFee",
    "liquidationThreshold",
    "ltv"
  ].includes(key))
    return `${reserve[key] / 100} %`;
  if (["supplyCap", "borrowCap"].includes(key))
    return `${reserve[key].toLocaleString("en-US")} ${reserve.symbol}`;
  if (key === "liquidationBonus")
    return `${(reserve[key] - 1e4) / 100} %`;
  if (key === "interestRateStrategy")
    return getBlockExplorerLink[chainId](reserve[key]);
  if (key === "oracleLatestAnswer" && reserve.oracleDecimals)
    return formatUnits(BigInt(reserve[key]), reserve.oracleDecimals);
  if (typeof reserve[key] === "number")
    return reserve[key].toLocaleString("en-US");
  if (typeof reserve[key] === "string" && /0x.+/.test(reserve[key]))
    return getBlockExplorerLink[chainId](reserve[key]);
  return reserve[key];
}
function renderReserveHeadline(reserve, chainId) {
  return `#### ${reserve.symbol} (${getBlockExplorerLink[chainId](
    reserve.underlying
  )})

`;
}
var ORDER = [
  "supplyCap",
  "borrowCap",
  "oracle",
  "oracleDecimals",
  "oracleDescription",
  "oracleName",
  "oracleLatestAnswer"
];
function sortReserveKeys(a, b) {
  const indexA = ORDER.indexOf(a);
  const indexB = ORDER.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
function renderReserveConfig(reserve, chainId) {
  let content = "| description | value |\n| --- | --- |\n";
  const OMIT_KEYS2 = [
    "underlying",
    // already rendered in the header
    "symbol"
    // already rendered in the header
  ];
  Object.keys(reserve).filter((key) => !OMIT_KEYS2.includes(key)).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(key, reserve, chainId)} |
`;
  });
  return content;
}
function renderReserve(reserve, chainId) {
  let content = renderReserveHeadline(reserve, chainId);
  content += renderReserveConfig(reserve, chainId);
  return content;
}
function renderReserveDiff(diff2, chainId) {
  let content = renderReserveHeadline(diff2, chainId);
  content += "| description | value before | value after |\n| --- | --- | --- |\n";
  Object.keys(diff2).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortReserveKeys).map((key) => {
    content += `| ${key} | ${renderReserveValue(
      key,
      { ...diff2, [key]: diff2[key].from },
      chainId
    )} | ${renderReserveValue(
      key,
      { ...diff2, [key]: diff2[key].to },
      chainId
    )} |
`;
  });
  return content;
}

// src/renderer/strategy.ts
import { formatUnits as formatUnits2 } from "viem";
function renderStrategyValue(key, reserve) {
  return `${formatUnits2(BigInt(reserve[key]), 25)} %`;
}
var ORDER2 = [
  "optimalUsageRatio",
  "maxExcessUsageRatio",
  "baseVariableBorrowRate",
  "variableRateSlope1",
  "variableRateSlope2",
  "baseStableBorrowRate",
  "stableRateSlope1",
  "stableRateSlope2",
  "optimalStableToTotalDebtRatio",
  "maxExcessStableToTotalDebtRatio"
];
function sortStrategyKeys(a, b) {
  const indexA = ORDER2.indexOf(a);
  const indexB = ORDER2.indexOf(b);
  if (indexA != -1 && indexB != -1) {
    if (indexA > indexB) {
      return 1;
    }
    if (indexB > indexA) {
      return -1;
    }
  }
  if (indexA != -1)
    return -1;
  if (indexB != -1)
    return -1;
  return a.localeCompare(b);
}
var OMIT_KEYS = [
  "address"
  // already rendered in the reserve
];
function renderStrategy(strategy) {
  let content = "";
  Object.keys(strategy).filter((key) => !OMIT_KEYS.includes(key)).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, strategy)} |
`;
  });
  return content;
}
function renderStrategyDiff(diff2) {
  let content = "";
  Object.keys(diff2).filter((key) => !OMIT_KEYS.includes(key)).filter((key) => diff2[key].hasOwnProperty("from")).sort(sortStrategyKeys).map((key) => {
    content += `| ${key} | ${renderStrategyValue(key, {
      ...diff2,
      [key]: diff2[key].from
    })} | ${renderStrategyValue(key, { ...diff2, [key]: diff2[key].to })} |
`;
  });
  return content;
}

// src/utils/diff.ts
function diff(a, b, removeUnchanged) {
  const out = {};
  for (const key in a) {
    if (!b.hasOwnProperty(key)) {
      out[key] = { from: a[key], to: null };
    } else {
      if (typeof a[key] === "object") {
        const tempDiff = diff(a[key], b[key], removeUnchanged);
        if (Object.keys(tempDiff).length > 0) {
          out[key] = tempDiff;
        }
      } else {
        if (b[key] == a[key]) {
          if (!removeUnchanged)
            out[key] = a[key];
        } else {
          out[key] = { from: a[key], to: b[key] };
        }
      }
    }
  }
  for (const key in b) {
    if (a.hasOwnProperty(key))
      continue;
    out[key] = { from: null, to: b[key] };
  }
  return out;
}

// src/diffReports.ts
async function diffReports(pre, post) {
  const chainId = pre.chainId;
  const diffResult = diff(pre, post);
  for (const ir in pre.strategies) {
    await fetchRateStrategyImage(pre.strategies[ir]);
  }
  for (const ir in post.strategies) {
    await fetchRateStrategyImage(post.strategies[ir]);
  }
  let content = "";
  const reservesAdded = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].to) {
      let report = renderReserve(
        diffResult.reserves[reserveKey].to,
        chainId
      );
      const imageHash = hash2(
        post.strategies[diffResult.reserves[reserveKey].to.interestRateStrategy]
      );
      report += renderStrategy(
        post.strategies[diffResult.reserves[reserveKey].to.interestRateStrategy]
      );
      report += `| interestRate | ![ir](/.assets/${imageHash}.svg) |`;
      return report;
    }
  }).filter((i) => i);
  const reservesRemoved = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (diffResult.reserves[reserveKey].from) {
      return renderReserve(
        diffResult.reserves[reserveKey].from,
        chainId
      );
    }
  }).filter((i) => i);
  const reservesAltered = Object.keys(diffResult.reserves).map((reserveKey) => {
    if (!diffResult.reserves[reserveKey].hasOwnProperty("from") && Object.keys(diffResult.reserves[reserveKey]).find(
      (fieldKey) => typeof diffResult.reserves[reserveKey][fieldKey] === "object"
    )) {
      let report = renderReserveDiff(
        diffResult.reserves[reserveKey],
        chainId
      );
      if (diffResult.reserves[reserveKey].interestRateStrategy.hasOwnProperty(
        "from"
      )) {
        report += renderStrategyDiff(
          diff(
            pre.strategies[diffResult.reserves[reserveKey].interestRateStrategy.from],
            post.strategies[diffResult.reserves[reserveKey].interestRateStrategy.to]
          )
        );
        report += `| interestRate | ![before](/.assets/${hash2(
          pre.strategies[diffResult.reserves[reserveKey].interestRateStrategy.from]
        )}.svg) | ![after](/.assets/${hash2(
          post.strategies[diffResult.reserves[reserveKey].interestRateStrategy.to]
        )}.svg) |`;
      }
      return report;
    }
  }).filter((i) => i);
  if (reservesAdded.length || reservesRemoved.length || reservesAltered.length) {
    content += "## Reserve changes\n\n";
    if (reservesAdded.length) {
      content += `### ${reservesAdded.length > 1 ? "Reserve" : "Reserves"} added

`;
      content += reservesAdded.join("\n\n");
      content += "\n\n";
    }
    if (reservesAltered.length) {
      content += `### ${reservesAltered.length > 1 ? "Reserve" : "Reserves"} altered

`;
      content += reservesAltered.join("\n\n");
      content += "\n\n";
    }
    if (reservesRemoved.length) {
      content += `### ${reservesRemoved.length > 1 ? "Reserve" : "Reserves"} removed

`;
      content += reservesRemoved.join("\n\n");
      content += "\n\n";
    }
  }
  content += `## Raw diff

\`\`\`json
${JSON.stringify(
    diff(pre, post, true),
    null,
    2
  )}
\`\`\``;
  return content;
}

export {
  diffReports
};
/**
 * Highly inspired by - reimplemented a bit simpler & added types
 * @license MIT https://github.com/omgaz/diffler
 * Author: Gary Chisholm @omgaz
 */
//# sourceMappingURL=chunk-BIVQ42I3.js.map