"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeEventTopics = void 0;
const index_js_1 = require("../../errors/index.js");
const index_js_2 = require("../encoding/index.js");
const index_js_3 = require("../hash/index.js");
const encodeAbiParameters_js_1 = require("./encodeAbiParameters.js");
const formatAbiItem_js_1 = require("./formatAbiItem.js");
const getAbiItem_js_1 = require("./getAbiItem.js");
function encodeEventTopics({ abi, eventName, args }) {
    const abiItem = (0, getAbiItem_js_1.getAbiItem)({
        abi,
        args,
        name: eventName,
    });
    if (!abiItem)
        throw new index_js_1.AbiEventNotFoundError(eventName, {
            docsPath: '/docs/contract/encodeEventTopics',
        });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, index_js_3.getEventSelector)(definition);
    let topics = [];
    if (args && 'inputs' in abiItem) {
        const args_ = Array.isArray(args)
            ? args
            : abiItem.inputs?.map((x) => args[x.name]) ?? [];
        topics =
            abiItem.inputs
                ?.filter((param) => 'indexed' in param && param.indexed)
                .map((param, i) => Array.isArray(args_[i])
                ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }))
                : args_[i]
                    ? encodeArg({ param, value: args_[i] })
                    : null) ?? [];
    }
    return [signature, ...topics];
}
exports.encodeEventTopics = encodeEventTopics;
function encodeArg({ param, value, }) {
    if (param.type === 'string' || param.type === 'bytes')
        return (0, index_js_3.keccak256)((0, index_js_2.toBytes)(value));
    if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new index_js_1.FilterTypeNotSupportedError(param.type);
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
}
//# sourceMappingURL=encodeEventTopics.js.map