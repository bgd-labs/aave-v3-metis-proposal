"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeAbiParameters = void 0;
const index_js_1 = require("../../errors/index.js");
const index_js_2 = require("../address/index.js");
const index_js_3 = require("../data/index.js");
const index_js_4 = require("../encoding/index.js");
const encodeAbiParameters_js_1 = require("./encodeAbiParameters.js");
function decodeAbiParameters(params, data) {
    if (data === '0x' && params.length > 0)
        throw new index_js_1.AbiDecodingZeroDataError();
    if ((0, index_js_3.size)(data) % 32 !== 0)
        throw new index_js_1.AbiDecodingDataSizeInvalidError({ data, size: (0, index_js_3.size)(data) });
    return decodeParams({
        data,
        params: params,
    });
}
exports.decodeAbiParameters = decodeAbiParameters;
function decodeParams({ data, params, }) {
    const decodedValues = [];
    let position = 0;
    for (let i = 0; i < params.length; i++) {
        if (position >= (0, index_js_3.size)(data))
            throw new index_js_1.AbiDecodingDataSizeTooSmallError({
                data,
                params,
                size: (0, index_js_3.size)(data),
            });
        const param = params[i];
        const { consumed, value } = decodeParam({ data, param, position });
        decodedValues.push(value);
        position += consumed;
    }
    return decodedValues;
}
function decodeParam({ data, param, position, }) {
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
            length,
            param: { ...param, type: type },
            position,
        });
    }
    if (param.type === 'tuple') {
        return decodeTuple(data, { param: param, position });
    }
    if (param.type === 'string') {
        return decodeString(data, { position });
    }
    if (param.type.startsWith('bytes')) {
        return decodeBytes(data, { param, position });
    }
    const value = (0, index_js_3.slice)(data, position, position + 32);
    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
        return decodeNumber(value, { param });
    }
    if (param.type === 'address') {
        return decodeAddress(value);
    }
    if (param.type === 'bool') {
        return decodeBool(value);
    }
    throw new index_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: '/docs/contract/decodeAbiParameters',
    });
}
function decodeAddress(value) {
    return { consumed: 32, value: (0, index_js_2.checksumAddress)((0, index_js_3.slice)(value, -20)) };
}
function decodeArray(data, { param, length, position, }) {
    if (!length) {
        const offset = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, position, position + 32));
        const length = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, offset, offset + 32));
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const decodedChild = decodeParam({
                data: (0, index_js_3.slice)(data, offset + 32),
                param,
                position: consumed,
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return { value, consumed: 32 };
    }
    if (hasDynamicChild(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const offset = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, position, position + 32));
            const decodedChild = decodeParam({
                data: (0, index_js_3.slice)(data, offset),
                param,
                position: dynamicChild ? consumed : i * 32,
            });
            consumed += decodedChild.consumed;
            value.push(decodedChild.value);
        }
        return { value, consumed: 32 };
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam({
            data,
            param,
            position: position + consumed,
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
    }
    return { value, consumed };
}
function decodeBool(value) {
    return { consumed: 32, value: (0, index_js_4.hexToBool)(value) };
}
function decodeBytes(data, { param, position }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        const offset = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, position, position + 32));
        const length = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, offset, offset + 32));
        if (length === 0)
            return { consumed: 32, value: '0x' };
        const value = (0, index_js_3.slice)(data, offset + 32, offset + 32 + length);
        return { consumed: 32, value };
    }
    const value = (0, index_js_3.slice)(data, position, position + parseInt(size));
    return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
    const signed = param.type.startsWith('int');
    const size = parseInt(param.type.split('int')[1] || '256');
    return {
        consumed: 32,
        value: size > 48
            ? (0, index_js_4.hexToBigInt)(value, { signed })
            : (0, index_js_4.hexToNumber)(value, { signed }),
    };
}
function decodeString(data, { position }) {
    const offset = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, position, position + 32));
    const length = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, offset, offset + 32));
    if (length === 0)
        return { consumed: 32, value: '' };
    const value = (0, index_js_4.hexToString)((0, index_js_3.trim)((0, index_js_3.slice)(data, offset + 32, offset + 32 + length)));
    return { consumed: 32, value };
}
function decodeTuple(data, { param, position }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
        const offset = (0, index_js_4.hexToNumber)((0, index_js_3.slice)(data, position, position + 32));
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            const decodedChild = decodeParam({
                data: (0, index_js_3.slice)(data, offset),
                param: component,
                position: consumed,
            });
            consumed += decodedChild.consumed;
            value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
    }
    for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
            data,
            param: component,
            position: position + consumed,
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
    }
    return { consumed, value };
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string')
        return true;
    if (type === 'bytes')
        return true;
    if (type.endsWith('[]'))
        return true;
    if (type === 'tuple')
        return param.components?.some(hasDynamicChild);
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents &&
        hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
    return false;
}
//# sourceMappingURL=decodeAbiParameters.js.map