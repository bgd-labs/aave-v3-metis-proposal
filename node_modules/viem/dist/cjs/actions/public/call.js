"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.call = void 0;
const index_js_1 = require("../../constants/index.js");
const index_js_2 = require("../../errors/index.js");
const index_js_3 = require("../../utils/index.js");
const createBatchScheduler_js_1 = require("../../utils/promise/createBatchScheduler.js");
async function call(client, args) {
    const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'latest', accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const account = account_ ? (0, index_js_3.parseAccount)(account_) : undefined;
    try {
        (0, index_js_3.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, index_js_3.numberToHex)(blockNumber) : undefined;
        const formatter = client.chain?.formatters?.transactionRequest;
        const request = (0, index_js_3.format)({
            from: account?.address,
            accessList,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...(0, index_js_3.extract)(rest, { formatter }),
        }, {
            formatter: formatter || index_js_3.formatTransactionRequest,
        });
        if (batch && shouldPerformMulticall({ request })) {
            try {
                return await scheduleMulticall(client, {
                    ...request,
                    blockNumber,
                    blockTag,
                });
            }
            catch (err) {
                if (!(err instanceof index_js_2.ClientChainNotConfiguredError) &&
                    !(err instanceof index_js_2.ChainDoesNotSupportContract))
                    throw err;
            }
        }
        const response = await client.request({
            method: 'eth_call',
            params: [request, blockNumberHex || blockTag],
        });
        if (response === '0x')
            return { data: undefined };
        return { data: response };
    }
    catch (err) {
        throw (0, index_js_3.getCallError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
exports.call = call;
function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
        return false;
    if (data.startsWith(index_js_1.aggregate3Signature))
        return false;
    if (!to)
        return false;
    if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
        return false;
    return true;
}
async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch?.multicall : {};
    const { blockNumber, blockTag = 'latest', data, multicallAddress: multicallAddress_, to, } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain)
            throw new index_js_2.ClientChainNotConfiguredError();
        multicallAddress = (0, index_js_3.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3',
        });
    }
    const blockNumberHex = blockNumber ? (0, index_js_3.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args) {
            const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
            return size > batchSize * 2;
        },
        fn: async (requests) => {
            const calls = requests.map((request) => ({
                allowFailure: true,
                callData: request.data,
                target: request.to,
            }));
            const calldata = (0, index_js_3.encodeFunctionData)({
                abi: index_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
            });
            const data = await client.request({
                method: 'eth_call',
                params: [
                    {
                        data: calldata,
                        to: multicallAddress,
                    },
                    block,
                ],
            });
            return (0, index_js_3.decodeFunctionResult)({
                abi: index_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
                data: data || '0x',
            });
        },
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
        throw new index_js_2.RawContractError({ data: returnData });
    if (returnData === '0x')
        return { data: undefined };
    return { data: returnData };
}
//# sourceMappingURL=call.js.map